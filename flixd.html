<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FlixD</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', sans-serif;
      background: linear-gradient(145deg, #1a1a2e 0%, #0f0f1a 50%, #1a1a2e 100%);
      color: #f5f5f7;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
    }

    /* Clock */
    .clock {
      position: fixed;
      top: 40px;
      left: 50px;
      font-size: 1.1rem;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.7);
      z-index: 100;
      letter-spacing: 0.02em;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 100px 50px 50px;
    }

    h1 {
      font-size: 3rem;
      font-weight: 700;
      margin-bottom: 50px;
      color: #fff;
      letter-spacing: -0.02em;
    }

    .section {
      margin-bottom: 70px;
    }

    .section-title {
      font-size: 1.4rem;
      font-weight: 600;
      margin-bottom: 24px;
      color: rgba(255, 255, 255, 0.9);
      letter-spacing: -0.01em;
    }

    .video-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 28px;
    }

    .video-card {
      position: relative;
      background-color: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(40px);
      -webkit-backdrop-filter: blur(40px);
      border-radius: 16px;
      cursor: pointer;
      outline: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
      aspect-ratio: 16 / 9;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      background-size: cover;
      background-position: center;
      transform: scale(1);
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                  background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .video-card.has-thumbnail {
      background-color: #000;
    }

    .video-card.has-thumbnail .card-content {
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));
    }

    .card-content {
      padding: 16px;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      z-index: 1;
    }

    .video-card:hover,
    .video-card:focus {
      transform: scale(1.08);
      background-color: rgba(255, 255, 255, 0.15);
      border-color: #5e5ce6;
      box-shadow:
        0 0 0 3px rgba(94, 92, 230, 0.5),
        0 24px 80px rgba(0, 0, 0, 0.5),
        0 8px 24px rgba(94, 92, 230, 0.3);
    }

    .video-card.has-thumbnail:hover,
    .video-card.has-thumbnail:focus {
      background-color: #000;
    }

    .video-card .filename {
      font-size: 1rem;
      font-weight: 500;
      line-height: 1.4;
      color: #fff;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }

    .video-card .subtitle {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.6);
      margin-top: 4px;
    }

    .video-card .progress-bar {
      margin-top: 10px;
      height: 3px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 3px;
      overflow: hidden;
      flex-shrink: 0;
    }

    .video-card .progress-bar .progress {
      height: 100%;
      background: linear-gradient(90deg, #5e5ce6, #bf5af2);
      border-radius: 4px;
      transition: width 0.3s ease-out;
    }

    .video-card .meta {
      margin-top: 6px;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.5);
      font-weight: 400;
      flex-shrink: 0;
    }

    /* Episode list styling */
    .episode-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .episode-item {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      cursor: pointer;
      outline: none;
      transform: scale(1);
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                  background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .episode-item:hover,
    .episode-item:focus {
      transform: scale(1.02);
      background: rgba(255, 255, 255, 0.12);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    }

    .episode-item:focus {
      background: rgba(94, 92, 230, 0.15);
      box-shadow:
        0 0 0 3px rgba(94, 92, 230, 0.4),
        0 8px 24px rgba(0, 0, 0, 0.15);
    }

    .episode-item.pressed {
      transform: scale(0.99);
      background: rgba(94, 92, 230, 0.2);
      transition: transform 0.1s cubic-bezier(0.4, 0, 0.6, 1);
    }

    .episode-number {
      font-size: 1.2rem;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.4);
      min-width: 36px;
      text-align: center;
    }

    .episode-info {
      flex: 1;
      min-width: 0;
    }

    .episode-title {
      font-size: 1rem;
      font-weight: 500;
      color: #fff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .episode-progress {
      margin-top: 8px;
      height: 3px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 3px;
      overflow: hidden;
      max-width: 200px;
    }

    .episode-progress .progress {
      height: 100%;
      background: linear-gradient(90deg, #5e5ce6, #bf5af2);
      border-radius: 3px;
    }

    .episode-meta {
      font-size: 0.85rem;
      color: rgba(255, 255, 255, 0.5);
    }

    .watched-badge {
      color: #30d158;
    }

    .time-remaining {
      color: rgba(255, 255, 255, 0.5);
    }

    .video-card.loading {
      pointer-events: none;
      position: relative;
    }

    .video-card.loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 28px;
      height: 28px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top-color: #5e5ce6;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      z-index: 10;
    }

    .video-card.loading .card-content {
      visibility: hidden;
    }

    /* Hold-to-remove overlay */
    .video-card .hold-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      opacity: 0;
      pointer-events: none;
      z-index: 10;
      transition: opacity 0.15s ease-out;
    }

    .video-card .hold-overlay.visible {
      opacity: 1;
    }

    .video-card .hold-overlay .hold-label {
      font-size: 1rem;
      font-weight: 600;
      color: #fff;
      letter-spacing: 0.01em;
    }

    .video-card .hold-overlay .hold-progress-bar {
      width: 70%;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      overflow: hidden;
    }

    .video-card .hold-overlay .hold-progress-bar .fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #5e5ce6, #bf5af2);
      border-radius: 4px;
      transition: width 0.05s linear;
    }

    .video-card.holding .card-content {
      visibility: hidden;
    }

    /* Pressed/pushed state - immediate feedback */
    .video-card.pressed {
      transform: scale(0.98);
      background-color: rgba(255, 255, 255, 0.05);
      border-color: rgba(94, 92, 230, 0.5);
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.3);
      transition: transform 0.1s cubic-bezier(0.4, 0, 0.6, 1);
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(40px);
      -webkit-backdrop-filter: blur(40px);
      color: #fff;
      padding: 18px 36px;
      border-radius: 16px;
      font-size: 1rem;
      font-weight: 500;
      z-index: 2000;
      opacity: 0;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                  opacity 0.3s ease-out;
    }

    .toast.visible {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    .toast.error {
      background: rgba(255, 69, 58, 0.2);
      border-color: rgba(255, 69, 58, 0.3);
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: rgba(30, 30, 35, 0.9);
      backdrop-filter: blur(50px);
      -webkit-backdrop-filter: blur(50px);
      border-radius: 14px;
      padding: 6px;
      min-width: 220px;
      z-index: 1500;
      box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: none;
    }

    .context-menu.visible {
      display: block;
    }

    .context-menu-item {
      padding: 14px 18px;
      cursor: pointer;
      outline: none;
      font-size: 0.95rem;
      font-weight: 500;
      border-radius: 10px;
      color: #fff;
      transform: scale(1);
      transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1),
                  background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .context-menu-item:hover,
    .context-menu-item:focus {
      transform: scale(1.03);
      background: rgba(255, 255, 255, 0.1);
    }

    .context-menu-item:active {
      transform: scale(0.98);
    }

    /* Player View */
    .player-view {
      display: none;
      position: fixed;
      inset: 0;
      background: #000;
      z-index: 1000;
      flex-direction: column;
    }

    .player-view.active {
      display: flex;
    }

    .player-header {
      padding: 30px 40px;
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.95), transparent);
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 20px;
      opacity: 1;
      transition: opacity 0.3s ease-in-out;
    }

    .player-header.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .player-controls-hint {
      display: none;
    }

    .back-btn {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #fff;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 12px 16px;
      line-height: 1;
      border-radius: 12px;
      outline: none;
      transform: scale(1);
      transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1),
                  background-color 0.2s cubic-bezier(0.4, 0, 0.2, 1),
                  box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .back-btn:hover,
    .back-btn:focus {
      transform: scale(1.1);
      background: rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    .back-btn:focus {
      box-shadow:
        0 0 0 3px rgba(94, 92, 230, 0.5),
        0 4px 16px rgba(0, 0, 0, 0.2);
    }

    .back-btn:active {
      transform: scale(0.95);
    }

    .player-title {
      font-size: 1.2rem;
      font-weight: 600;
      color: #fff;
    }

    .player-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .seek-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      padding: 20px 40px;
      border-radius: 16px;
      font-size: 2rem;
      font-weight: 600;
      color: #fff;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease-out;
    }

    .seek-indicator.visible {
      opacity: 1;
    }

    video {
      max-width: 100%;
      max-height: 100%;
      width: 100%;
      border-radius: 0;
    }

    /* Custom Player Controls - TV Remote Optimized */
    .player-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 30px 60px 50px;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.8) 50%, transparent);
      z-index: 10;
      opacity: 1;
      transition: opacity 0.3s ease-in-out;
    }

    .player-controls.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .progress-container {
      margin-bottom: 24px;
      cursor: pointer;
      position: relative;
    }

    .progress-bar-player {
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      position: relative;
      overflow: hidden;
      transition: height 0.15s ease-out;
    }

    .progress-container:hover .progress-bar-player,
    .progress-container.scrubbing .progress-bar-player {
      height: 10px;
    }

    .progress-buffered {
      position: absolute;
      height: 100%;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      width: 0%;
    }

    .progress-played {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, #5e5ce6, #bf5af2);
      border-radius: 6px;
      width: 0%;
    }

    .progress-thumb {
      position: absolute;
      top: 3px;  /* Half of progress bar height */
      transform: translate(-50%, -50%);
      width: 16px;
      height: 16px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      opacity: 0;
      pointer-events: none;
      z-index: 2;
      transition: opacity 0.15s ease-out, top 0.15s ease-out;
    }

    .progress-container:hover .progress-thumb,
    .progress-container.scrubbing .progress-thumb {
      opacity: 1;
      top: 5px;  /* Adjust when bar is taller on hover */
    }

    .progress-container.scrubbing .progress-thumb {
      transform: translate(-50%, -50%) scale(1.3);
    }

    .progress-hover-time {
      position: absolute;
      bottom: 24px;
      background: rgba(0, 0, 0, 0.85);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.9rem;
      color: #fff;
      transform: translateX(-50%);
      opacity: 0;
      pointer-events: none;
      white-space: nowrap;
      transition: opacity 0.15s ease-out;
    }

    .progress-container:hover .progress-hover-time {
      opacity: 1;
    }

    .progress-time {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.6);
      font-variant-numeric: tabular-nums;
    }

    .controls-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }

    /* TV Control Button - Large, Clear Focus */
    .tv-control-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 3px solid transparent;
      color: #fff;
      width: 80px;
      height: 80px;
      border-radius: 20px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
      outline: none;
      position: relative;
      transform: scale(1);
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                  background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .tv-control-btn svg {
      width: 32px;
      height: 32px;
    }

    .tv-control-btn::after {
      content: attr(data-label);
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.6);
      position: absolute;
      bottom: 8px;
      white-space: nowrap;
      transition: color 0.15s ease-out;
    }

    /* Focused state - very visible for TV */
    .tv-control-btn:focus {
      transform: scale(1.15);
      background: rgba(94, 92, 230, 0.4);
      border-color: #5e5ce6;
      box-shadow:
        0 0 0 4px rgba(94, 92, 230, 0.3),
        0 0 40px rgba(94, 92, 230, 0.6),
        0 8px 24px rgba(0, 0, 0, 0.3);
    }

    .tv-control-btn:active {
      transform: scale(0.95);
      transition: transform 0.1s cubic-bezier(0.4, 0, 0.6, 1);
    }

    .tv-control-btn:focus::after {
      color: #fff;
    }

    /* Play/Pause button - larger */
    .tv-control-btn.play-pause {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.15);
    }

    .tv-control-btn.play-pause svg {
      width: 44px;
      height: 44px;
    }

    .tv-control-btn.play-pause::after {
      bottom: -28px;
    }

    /* Play/Pause icon toggle */
    .tv-control-btn.play-pause .pause-icon,
    .tv-control-btn.play-pause.playing .play-icon {
      display: none;
    }

    .tv-control-btn.play-pause.playing .pause-icon {
      display: block;
    }

    /* Active state (subtitles on) */
    .tv-control-btn.active {
      background: rgba(94, 92, 230, 0.3);
    }

    .tv-control-btn.active::after {
      color: #5e5ce6;
    }

    /* Loading */
    .loading {
      text-align: center;
      padding: 100px 20px;
      color: rgba(255, 255, 255, 0.5);
    }

    .loading::after {
      content: '';
      display: block;
      width: 36px;
      height: 36px;
      margin: 24px auto 0;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top-color: #5e5ce6;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }


    .error {
      text-align: center;
      padding: 100px 20px;
      color: #ff453a;
      font-weight: 500;
    }

    .empty {
      color: rgba(255, 255, 255, 0.4);
      padding: 30px 0;
      font-size: 1.1rem;
    }

    /* Config prompt */
    .config-prompt {
      max-width: 650px;
      margin: 50px auto;
      padding: 40px;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(40px);
      -webkit-backdrop-filter: blur(40px);
      border-radius: 24px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .config-prompt h1 {
      font-size: 1.8rem;
      margin-bottom: 16px;
    }

    .config-prompt p {
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 16px;
    }

    .config-prompt ol {
      color: rgba(255, 255, 255, 0.8);
    }

    .config-prompt a {
      color: #5e5ce6;
    }

    .config-prompt code {
      display: block;
      background: rgba(0, 0, 0, 0.4);
      padding: 16px;
      border-radius: 14px;
      text-align: left;
      font-size: 0.85rem;
      overflow-x: auto;
      color: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.05);
      white-space: pre-wrap;
      word-break: break-all;
    }

    /* Series detail view */
    .series-header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 30px;
    }

    .series-header h1 {
      margin: 0;
    }

    .series-back {
      flex-shrink: 0;
    }

    .season-tabs {
      display: flex;
      gap: 12px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .season-tab {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.7);
      padding: 12px 24px;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      font-family: inherit;
      transform: scale(1);
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                  background-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  border-color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  color 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                  box-shadow 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .season-tab:hover,
    .season-tab:focus {
      transform: scale(1.05);
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.2);
      color: #fff;
      outline: none;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    }

    .season-tab:focus {
      box-shadow:
        0 0 0 3px rgba(94, 92, 230, 0.5),
        0 4px 16px rgba(0, 0, 0, 0.15);
      border-color: #5e5ce6;
    }

    .season-tab:active {
      transform: scale(0.98);
      transition: transform 0.1s cubic-bezier(0.4, 0, 0.6, 1);
    }

    .season-tab.active {
      background: rgba(94, 92, 230, 0.3);
      border-color: rgba(94, 92, 230, 0.5);
      color: #fff;
    }

    /* Series card styling */
    .series-card:not(.has-thumbnail) {
      background: linear-gradient(145deg, rgba(94, 92, 230, 0.15), rgba(191, 90, 242, 0.1));
      border-color: rgba(94, 92, 230, 0.2);
    }

    .series-card:not(.has-thumbnail):hover,
    .series-card:not(.has-thumbnail):focus {
      background: linear-gradient(145deg, rgba(94, 92, 230, 0.25), rgba(191, 90, 242, 0.15));
      border-color: rgba(94, 92, 230, 0.4);
    }
  </style>
</head>
<body>

<!-- ===================== -->
<!-- CONFIGURATION         -->
<!-- ===================== -->
<script>
  // Get refresh token once using setup instructions below, then it works forever
  const CONFIG = {
    appKey: 'ral76dcspmytq72',
    appSecret: 'fy0wzhlm4r8zifg',
    refreshToken: '0KmR1TzeliEAAAAAAAAAAbQrCeVlRnjzNVyH9o9dcRQuUDwI53-RLZeXG4AEdMAw',
    folderPath: ''
  };
</script>
<!-- ===================== -->

<div class="clock" id="clock"></div>

<div class="container" id="app">
  <div class="loading">Loading your videos...</div>
</div>

<div class="player-view" id="playerView">
  <div class="player-header" id="playerHeader">
    <button class="back-btn" id="backBtn" tabindex="-1">‹</button>
    <span class="player-title" id="playerTitle"></span>
  </div>
  
  <div class="player-container">
    <video id="videoPlayer" tabindex="-1"></video>
    <div class="seek-indicator" id="seekIndicator"></div>
  </div>

  <div class="player-controls" id="playerControls">
    <div class="progress-container" id="progressContainer">
      <div class="progress-bar-player">
        <div class="progress-buffered" id="progressBuffered"></div>
        <div class="progress-played" id="progressPlayed"></div>
      </div>
      <div class="progress-thumb" id="progressThumb"></div>
      <div class="progress-hover-time" id="progressHoverTime">0:00</div>
      <div class="progress-time">
        <span id="currentTime">0:00</span>
        <span id="duration">0:00</span>
      </div>
    </div>
    
    <div class="controls-row" id="controlsRow">
      <button class="tv-control-btn" id="restartBtn" data-label="Restart">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
      </button>
      <button class="tv-control-btn" id="rewindBtn" data-label="−10s">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>
      </button>
      <button class="tv-control-btn play-pause" id="playPauseBtn" data-label="Play">
        <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
        <svg class="pause-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
      </button>
      <button class="tv-control-btn" id="forwardBtn" data-label="+10s">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>
      </button>
      <button class="tv-control-btn" id="nextEpisodeBtn" data-label="Next" style="display: none;">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
      </button>
      <button class="tv-control-btn" id="subtitlesBtn" data-label="Subtitles" style="display: none;">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V6h16v12zM6 10h2v2H6zm0 4h8v2H6zm10 0h2v2h-2zm-6-4h8v2h-8z"/></svg>
      </button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<div class="context-menu" id="contextMenu">
  <div class="context-menu-item" tabindex="0" data-action="remove">Remove from Up Next</div>
  <div class="context-menu-item" tabindex="0" data-action="markComplete">Mark as Watched</div>
</div>

<script>
  const STORAGE_KEY = 'dropbox_video_progress';
  const TOKEN_STORAGE_KEY = 'flixd_access_token_v2';
  const TOKEN_EXPIRY_KEY = 'flixd_token_expiry_v2';
  const DROPBOX_DATA_FILE = '/flixd-data.json';

  // Token state - cached in localStorage
  let accessToken = localStorage.getItem(TOKEN_STORAGE_KEY) || '';
  let tokenExpiry = parseInt(localStorage.getItem(TOKEN_EXPIRY_KEY) || '0');

  // Get valid access token, refreshing if needed
  async function getAccessToken() {
    const now = Date.now();
    
    // If token exists and won't expire in next 5 minutes, use it
    if (accessToken && tokenExpiry > now + 300000) {
      return accessToken;
    }

    // Refresh the token
    console.log('Refreshing Dropbox access token...');
    
    const credentials = btoa(`${CONFIG.appKey}:${CONFIG.appSecret}`);
    const response = await fetch('https://api.dropboxapi.com/oauth2/token', {
      method: 'POST',
      headers: {
        'Authorization': `Basic ${credentials}`,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: `grant_type=refresh_token&refresh_token=${CONFIG.refreshToken}`
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Token refresh failed: ${error}`);
    }

    const data = await response.json();
    accessToken = data.access_token;
    tokenExpiry = now + (data.expires_in * 1000); // Convert seconds to ms

    // Cache in localStorage
    localStorage.setItem(TOKEN_STORAGE_KEY, accessToken);
    localStorage.setItem(TOKEN_EXPIRY_KEY, tokenExpiry.toString());

    console.log('Token refreshed successfully');
    return accessToken;
  }

  // Dropbox data file operations
  async function loadWatchHistoryFromDropbox() {
    const token = await getAccessToken();
    
    try {
      const response = await fetch('https://content.dropboxapi.com/2/files/download', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Dropbox-API-Arg': JSON.stringify({ path: DROPBOX_DATA_FILE })
        }
      });

      if (response.status === 409) {
        // File doesn't exist yet, return empty
        console.log('No existing watch history, starting fresh');
        return {};
      }

      if (!response.ok) {
        throw new Error(`Failed to load: ${response.status}`);
      }

      const data = await response.json();
      console.log('Watch history loaded from Dropbox');
      return data;
    } catch (err) {
      console.warn('Could not load watch history from Dropbox:', err);
      return {};
    }
  }

  let saveTimeout = null;
  async function saveWatchHistoryToDropbox() {
    // Debounce saves - wait 2 seconds after last change
    if (saveTimeout) clearTimeout(saveTimeout);
    
    saveTimeout = setTimeout(async () => {
      const token = await getAccessToken();
      
      try {
        const response = await fetch('https://content.dropboxapi.com/2/files/upload', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Dropbox-API-Arg': JSON.stringify({
              path: DROPBOX_DATA_FILE,
              mode: 'overwrite',
              mute: true // Don't trigger notifications
            }),
            'Content-Type': 'application/octet-stream'
          },
          body: JSON.stringify(watchHistory, null, 2)
        });

        if (!response.ok) {
          throw new Error(`Failed to save: ${response.status}`);
        }
        
        console.log('Watch history saved to Dropbox');
      } catch (err) {
        console.error('Could not save watch history to Dropbox:', err);
      }
    }, 2000);
  }

  // State
  let videos = [];
  let movies = [];
  let series = {}; // { "Show Name": { "Season 1": [...episodes], "Season 2": [...] } }
  let watchHistory = loadWatchHistory();
  let lastFocusedCardId = null;
  let contextMenuVideoId = null;
  
  // View state
  let currentView = 'home'; // 'home' or 'series'
  let currentSeries = null; // series name when viewing a show
  let currentSeason = null; // selected season
  let toastTimeout = null;
  
  // Hold-to-remove state
  let holdTimer = null;
  let holdProgressInterval = null;
  let holdStartTime = null;
  let holdCard = null;
  let buttonReleased = true;
  const HOLD_DELAY = 1000; // Time before label appears (ms)
  const HOLD_FILL_DURATION = 2000; // Time for progress bar to fill (ms)

  // Utility: Escape HTML to prevent XSS
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Utility: Strip file extension from filename
  function stripExtension(filename) {
    const lastDot = filename.lastIndexOf('.');
    if (lastDot > 0) {
      return filename.substring(0, lastDot);
    }
    return filename;
  }

  function loadWatchHistory() {
    // Sync version for initial state - actual load happens in init()
    return {};
  }

  function saveWatchHistory() {
    // Save to Dropbox (debounced)
    saveWatchHistoryToDropbox();
  }

  function getProgress(fileId) {
    return watchHistory[fileId] || null;
  }

  function updateProgress(fileId, position, duration) {
    watchHistory[fileId] = {
      position,
      duration,
      lastWatched: Date.now()
    };
    saveWatchHistory();
  }

  function removeFromHistory(fileId) {
    delete watchHistory[fileId];
    saveWatchHistory();
  }

  function markAsComplete(fileId) {
    const progress = watchHistory[fileId];
    if (progress) {
      progress.position = progress.duration; // Set to 100%
    } else {
      // Create a complete entry even if not started
      watchHistory[fileId] = {
        position: 1,
        duration: 1,
        lastWatched: Date.now()
      };
    }
    saveWatchHistory();
  }

  // Toast notifications
  function showToast(message, isError = false) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.classList.toggle('error', isError);
    toast.classList.add('visible');
    
    // Clear existing timeout to prevent premature hide
    if (toastTimeout) clearTimeout(toastTimeout);
    toastTimeout = setTimeout(() => {
      toast.classList.remove('visible');
      toastTimeout = null;
    }, 3000);
  }

  // Dropbox API
  async function listVideos() {
    const videoExtensions = ['.mp4', '.mkv', '.avi', '.mov', '.webm', '.m4v'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.webp'];
    let allEntries = [];
    let cursor = null;
    let hasMore = true;

    const token = await getAccessToken();

    // Initial request
    const initialResponse = await fetch('https://api.dropboxapi.com/2/files/list_folder', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        path: CONFIG.folderPath,
        recursive: true,
        include_media_info: true,
        limit: 2000
      })
    });

    const initialData = await initialResponse.json();
    
    if (!initialResponse.ok) {
      console.error('Dropbox error:', initialData);
      throw new Error(initialData.error_summary || `Dropbox API error: ${initialResponse.status}`);
    }

    allEntries = initialData.entries;
    hasMore = initialData.has_more;
    cursor = initialData.cursor;

    // Continue fetching if more results exist
    while (hasMore) {
      const continueResponse = await fetch('https://api.dropboxapi.com/2/files/list_folder/continue', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ cursor })
      });

      const continueData = await continueResponse.json();

      if (!continueResponse.ok) {
        console.error('Dropbox pagination error:', continueData);
        break;
      }

      allEntries = allEntries.concat(continueData.entries);
      hasMore = continueData.has_more;
      cursor = continueData.cursor;
    }
    
    // Separate files by type
    const videoFiles = [];
    const thumbnails = {}; // path -> temporary link will be fetched on demand
    const thumbnailPaths = {}; // folder path -> thumbnail file path
    const descriptions = {}; // folder path -> description text (to be loaded)
    const descriptionPaths = {}; // folder path -> description file path

    for (const entry of allEntries) {
      if (entry['.tag'] !== 'file') continue;
      
      const ext = entry.name.toLowerCase().slice(entry.name.lastIndexOf('.'));
      const folderPath = entry.path_lower.substring(0, entry.path_lower.lastIndexOf('/'));
      
      if (videoExtensions.includes(ext)) {
        videoFiles.push({
          id: entry.id,
          name: entry.name,
          path: entry.path_lower,
          pathDisplay: entry.path_display,
          size: entry.size
        });
      } else if (entry.name.toLowerCase().startsWith('thumbnail') && imageExtensions.includes(ext)) {
        thumbnailPaths[folderPath] = entry.path_lower;
      } else if (entry.name.toLowerCase() === 'description.txt') {
        descriptionPaths[folderPath] = entry.path_lower;
      }
    }

    // Organize by folder structure
    movies = [];
    series = {};
    
    for (const file of videoFiles) {
      const pathParts = file.pathDisplay.split('/').filter(p => p);
      
      if (pathParts.length >= 3 && pathParts[0].toLowerCase() === 'movies') {
        // Movie in folder: /Movies/Movie Name/file.mp4
        const movieFolder = pathParts[1];
        const folderPath = '/' + pathParts.slice(0, 2).join('/').toLowerCase();
        
        // Check if we already added this movie
        if (!movies.find(m => m.folder === movieFolder)) {
          movies.push({
            ...file,
            folder: movieFolder,
            displayName: movieFolder,
            thumbnailPath: thumbnailPaths[folderPath] || null,
            descriptionPath: descriptionPaths[folderPath] || null
          });
        }
      } else if (pathParts.length >= 4 && pathParts[0].toLowerCase() === 'series') {
        // Series episode: /Series/Show Name/Season X/Episode.mp4
        const showName = pathParts[1];
        const seasonName = pathParts[2];
        const showFolderPath = '/' + pathParts.slice(0, 2).join('/').toLowerCase();
        
        if (!series[showName]) {
          series[showName] = {
            seasons: {},
            thumbnailPath: thumbnailPaths[showFolderPath] || null,
            descriptionPath: descriptionPaths[showFolderPath] || null
          };
        }
        if (!series[showName].seasons[seasonName]) {
          series[showName].seasons[seasonName] = [];
        }
        series[showName].seasons[seasonName].push(file);
      }
    }

    // Sort episodes within each season
    for (const show of Object.keys(series)) {
      for (const season of Object.keys(series[show].seasons)) {
        series[show].seasons[season].sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));
      }
    }

    // Sort movies alphabetically
    movies.sort((a, b) => a.displayName.localeCompare(b.displayName));

    // Store paths for lazy loading
    window.thumbnailPaths = thumbnailPaths;
    window.descriptionPaths = descriptionPaths;

    // All videos for progress tracking
    return videoFiles;
  }

  // Get temporary link for thumbnail
  async function getThumbnailUrl(path) {
    if (!path) return null;
    
    try {
      const token = await getAccessToken();
      const response = await fetch('https://api.dropboxapi.com/2/files/get_temporary_link', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ path })
      });
      
      if (!response.ok) return null;
      const data = await response.json();
      return data.link;
    } catch {
      return null;
    }
  }

  // Load description text
  async function getDescription(path) {
    if (!path) return null;
    
    try {
      const token = await getAccessToken();
      const response = await fetch('https://content.dropboxapi.com/2/files/download', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Dropbox-API-Arg': JSON.stringify({ path })
        }
      });
      
      if (!response.ok) return null;
      return await response.text();
    } catch {
      return null;
    }
  }

  async function getStreamUrl(path) {
    const token = await getAccessToken();
    
    const response = await fetch('https://api.dropboxapi.com/2/files/get_temporary_link', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ path })
    });

    if (!response.ok) {
      throw new Error(`Failed to get stream URL: ${response.status}`);
    }

    const data = await response.json();
    return data.link;
  }

  // UI Rendering
  function render() {
    const app = document.getElementById('app');
    
    if (currentView === 'series' && currentSeries) {
      renderSeriesDetail(app);
    } else {
      renderHome(app);
    }
  }

  function renderHome(app) {
    // Get continue watching videos (both movies and episodes)
    const continueWatching = videos
      .filter(v => {
        const progress = getProgress(v.id);
        if (!progress || !progress.duration) return false;
        const percent = progress.position / progress.duration;
        const watchedSeconds = progress.position;
        return (watchedSeconds > 10 || percent > 0.02) && percent < 0.98;
      })
      .sort((a, b) => {
        const pA = getProgress(a.id);
        const pB = getProgress(b.id);
        return pB.lastWatched - pA.lastWatched;
      })
      .slice(0, 10);

    let html = '<h1>FlixD</h1>';

    // Up Next Section
    if (continueWatching.length > 0) {
      html += `
        <div class="section">
          <div class="section-title">Up Next</div>
          <div class="video-grid">
            ${continueWatching.map(v => renderUpNextCard(v)).join('')}
          </div>
        </div>
      `;
    }

    // Movies Section
    if (movies.length > 0) {
      html += `
        <div class="section">
          <div class="section-title">Movies</div>
          <div class="video-grid">
            ${movies.map(m => renderMovieCard(m)).join('')}
          </div>
        </div>
      `;
    }

    // Series Section
    const seriesNames = Object.keys(series).sort();
    if (seriesNames.length > 0) {
      html += `
        <div class="section">
          <div class="section-title">Series</div>
          <div class="video-grid">
            ${seriesNames.map(name => renderSeriesCard(name)).join('')}
          </div>
        </div>
      `;
    }

    // Empty state
    if (movies.length === 0 && seriesNames.length === 0) {
      html += `
        <div class="empty">
          No videos found. Organize your Dropbox app folder like this:<br><br>
          <code style="font-size: 0.85rem; text-align: left; display: inline-block;">
/Movies/Movie Name/movie.mp4<br>
/Movies/Movie Name/thumbnail.jpg<br>
/Movies/Movie Name/description.txt<br><br>
/Series/Show Name/thumbnail.jpg<br>
/Series/Show Name/description.txt<br>
/Series/Show Name/Season 1/S01E01.mp4
          </code>
        </div>
      `;
    }

    app.innerHTML = html;
    attachCardEventHandlers();
    restoreFocus();
    
    // Lazy load thumbnails
    loadVisibleThumbnails();
  }

  // Load thumbnails for visible cards
  async function loadVisibleThumbnails() {
    const cards = document.querySelectorAll('.video-card[data-thumbnail-path]');
    for (const card of cards) {
      const path = card.dataset.thumbnailPath;
      if (path && path !== 'null') {
        const url = await getThumbnailUrl(path);
        if (url) {
          card.style.backgroundImage = `url(${url})`;
          card.classList.add('has-thumbnail');
        }
      }
    }
  }

  function renderUpNextCard(video) {
    const progress = getProgress(video.id);
    const progressPercent = (progress && progress.duration) 
      ? (progress.position / progress.duration) * 100 
      : 0;
    
    const remaining = Math.floor((progress.duration - progress.position) / 60);
    const safeName = escapeHtml(stripExtension(video.name));
    
    // Find context (is it a movie or episode?)
    const pathParts = video.pathDisplay?.split('/').filter(p => p) || [];
    let subtitle = '';
    let thumbnailPath = null;
    
    if (pathParts[0]?.toLowerCase() === 'series' && pathParts.length >= 4) {
      const showName = pathParts[1];
      const seasonName = pathParts[2];
      subtitle = `${showName} · ${seasonName}`;
      if (series[showName]) {
        thumbnailPath = series[showName].thumbnailPath;
      }
    } else if (pathParts[0]?.toLowerCase() === 'movies' && pathParts.length >= 3) {
      const movie = movies.find(m => m.id === video.id);
      if (movie) {
        thumbnailPath = movie.thumbnailPath;
      }
    }

    return `
      <div class="video-card" data-id="${video.id}" data-in-upnext="true" data-thumbnail-path="${thumbnailPath}" tabindex="0">
        <div class="hold-overlay">
          <div class="hold-label">Hold to remove</div>
          <div class="hold-progress-bar">
            <div class="fill"></div>
          </div>
        </div>
        <div class="card-content">
          <div class="filename">${safeName}</div>
          ${subtitle ? `<div class="subtitle">${escapeHtml(subtitle)}</div>` : ''}
          <div class="progress-bar">
            <div class="progress" style="width: ${progressPercent}%"></div>
          </div>
          <div class="meta">${remaining} min remaining</div>
        </div>
      </div>
    `;
  }

  function renderMovieCard(movie) {
    const safeName = escapeHtml(movie.displayName);
    const progress = getProgress(movie.id);
    const progressPercent = (progress && progress.duration) 
      ? (progress.position / progress.duration) * 100 
      : 0;

    return `
      <div class="video-card" data-id="${movie.id}" data-in-upnext="false" data-thumbnail-path="${movie.thumbnailPath}" tabindex="0">
        <div class="card-content">
          <div class="filename">${safeName}</div>
          ${progressPercent > 0 ? `
            <div class="progress-bar">
              <div class="progress" style="width: ${progressPercent}%"></div>
            </div>
          ` : ''}
        </div>
      </div>
    `;
  }

  function renderSeriesDetail(app) {
    const show = series[currentSeries];
    const seasons = Object.keys(show.seasons).sort((a, b) => {
      const numA = parseInt(a.match(/\d+/)?.[0] || 0);
      const numB = parseInt(b.match(/\d+/)?.[0] || 0);
      return numA - numB;
    });

    // Skip season picker if only 1 season
    const hasSingleSeason = seasons.length === 1;
    
    if (!currentSeason || !show.seasons[currentSeason]) {
      currentSeason = seasons[0];
    }

    const episodes = show.seasons[currentSeason] || [];

    let html = `
      <div class="series-header">
        <button class="back-btn series-back" id="seriesBackBtn" tabindex="0">‹</button>
        <h1>${escapeHtml(currentSeries)}</h1>
      </div>
    `;
    
    // Only show season tabs if more than 1 season
    if (!hasSingleSeason) {
      html += `
        <div class="season-tabs">
          ${seasons.map(s => `
            <button class="season-tab ${s === currentSeason ? 'active' : ''}" data-season="${escapeHtml(s)}" tabindex="0">
              ${escapeHtml(s)}
            </button>
          `).join('')}
        </div>
      `;
    }
    
    html += `
      <div class="section">
        ${hasSingleSeason ? `<div class="section-title">${escapeHtml(currentSeason)}</div>` : ''}
        <div class="episode-list">
          ${episodes.map((ep, index) => renderEpisodeItem(ep, index + 1)).join('')}
        </div>
      </div>
    `;

    app.innerHTML = html;

    // Back button handler
    document.getElementById('seriesBackBtn').addEventListener('click', goBackToHome);
    document.getElementById('seriesBackBtn').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        goBackToHome();
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        const firstTab = document.querySelector('.season-tab');
        const firstEpisode = document.querySelector('.episode-item');
        if (firstTab) firstTab.focus();
        else if (firstEpisode) firstEpisode.focus();
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        const firstEpisode = document.querySelector('.episode-item');
        if (firstEpisode) firstEpisode.focus();
      }
    });

    // Season tab handlers
    document.querySelectorAll('.season-tab').forEach((tab, index, tabs) => {
      tab.addEventListener('click', () => {
        currentSeason = tab.dataset.season;
        render();
      });
      tab.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          currentSeason = tab.dataset.season;
          render();
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          const next = tabs[index + 1];
          if (next) next.focus();
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault();
          if (index === 0) {
            document.getElementById('seriesBackBtn').focus();
          } else {
            const prev = tabs[index - 1];
            if (prev) prev.focus();
          }
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          const firstEpisode = document.querySelector('.episode-item');
          if (firstEpisode) firstEpisode.focus();
        }
      });
    });

    // Episode item handlers
    attachEpisodeEventHandlers();
    
    // Focus first episode or restore focus
    if (lastFocusedCardId) {
      const lastCard = document.querySelector(`[data-id="${lastFocusedCardId}"]`);
      if (lastCard) {
        lastCard.focus();
      } else {
        const firstEpisode = document.querySelector('.episode-item');
        if (firstEpisode) firstEpisode.focus();
      }
    } else {
      const firstEpisode = document.querySelector('.episode-item');
      if (firstEpisode) firstEpisode.focus();
    }
  }

  function renderEpisodeItem(episode, episodeNumber) {
    const progress = getProgress(episode.id);
    const progressPercent = (progress && progress.duration) 
      ? (progress.position / progress.duration) * 100 
      : 0;
    
    const safeName = escapeHtml(stripExtension(episode.name));
    
    let meta = '';
    if (progress && progress.duration) {
      if (progressPercent >= 98) {
        meta = '<span class="watched-badge">✓ Watched</span>';
      } else if (progressPercent > 0) {
        const remaining = Math.floor((progress.duration - progress.position) / 60);
        meta = `<span class="time-remaining">${remaining} min left</span>`;
      }
    }

    return `
      <div class="episode-item" data-id="${episode.id}" tabindex="0">
        <div class="episode-number">${episodeNumber}</div>
        <div class="episode-info">
          <div class="episode-title">${safeName}</div>
          ${progressPercent > 0 && progressPercent < 98 ? `
            <div class="episode-progress">
              <div class="progress" style="width: ${progressPercent}%"></div>
            </div>
          ` : ''}
        </div>
        <div class="episode-meta">${meta}</div>
      </div>
    `;
  }

  function attachEpisodeEventHandlers() {
    document.querySelectorAll('.episode-item').forEach((item, index, items) => {
      item.addEventListener('click', () => {
        playVideo(item.dataset.id);
      });
      
      item.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          item.dataset.keydownReceived = 'true';
          item.classList.add('pressed');
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          const next = items[index + 1];
          if (next) next.focus();
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (index === 0) {
            const activeTab = document.querySelector('.season-tab.active');
            const backBtn = document.getElementById('seriesBackBtn');
            if (activeTab) activeTab.focus();
            else if (backBtn) backBtn.focus();
          } else {
            const prev = items[index - 1];
            if (prev) prev.focus();
          }
        }
      });
      
      item.addEventListener('keyup', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          item.classList.remove('pressed');

          // Only process if THIS item received keydown
          if (!item.dataset.keydownReceived) {
            return;
          }
          delete item.dataset.keydownReceived;

          playVideo(item.dataset.id);
        }
      });
    });
  }

  function goBackToHome() {
    currentView = 'home';
    currentSeries = null;
    currentSeason = null;
    lastFocusedCardId = null;
    render();
  }

  function renderSeriesCard(seriesName) {
    const show = series[seriesName];
    const seasonCount = Object.keys(show.seasons).length;
    let episodeCount = 0;
    for (const season of Object.values(show.seasons)) {
      episodeCount += season.length;
    }

    const safeName = escapeHtml(seriesName);

    return `
      <div class="video-card series-card" data-series="${safeName}" data-thumbnail-path="${show.thumbnailPath}" tabindex="0">
        <div class="card-content">
          <div class="filename">${safeName}</div>
          <div class="meta">${seasonCount} season${seasonCount !== 1 ? 's' : ''} · ${episodeCount} episode${episodeCount !== 1 ? 's' : ''}</div>
        </div>
      </div>
    `;
  }

  function attachCardEventHandlers() {
    // Video card handlers
    document.querySelectorAll('.video-card:not(.series-card)').forEach(card => {
      card.addEventListener('click', () => {
        if (document.getElementById('playerView').classList.contains('active')) return;
        playVideo(card.dataset.id);
      });
      
      // Keydown - handle hold-to-remove for Up Next items
      card.addEventListener('keydown', (e) => {
        if (document.getElementById('playerView').classList.contains('active')) return;

        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();

          if (!buttonReleased) return;

          // Mark that THIS card received a keydown
          card.dataset.keydownReceived = 'true';
          card.classList.add('pressed');
          
          const isUpNext = card.dataset.inUpnext === 'true';
          
          if (isUpNext && !holdTimer) {
            buttonReleased = false;
            holdCard = card;
            holdStartTime = Date.now();
            
            holdTimer = setTimeout(() => {
              card.classList.add('holding');
              const overlay = card.querySelector('.hold-overlay');
              const fillBar = card.querySelector('.hold-overlay .fill');
              if (overlay) overlay.classList.add('visible');
              
              const fillStartTime = Date.now();
              holdProgressInterval = setInterval(() => {
                const elapsed = Date.now() - fillStartTime;
                const progress = Math.min(elapsed / HOLD_FILL_DURATION, 1);
                if (fillBar) fillBar.style.width = `${progress * 100}%`;
                
                if (progress >= 1) {
                  clearInterval(holdProgressInterval);
                  holdProgressInterval = null;

                  const videoId = card.dataset.id;
                  removeFromHistory(videoId);
                  showToast('Removed from Up Next');

                  resetHoldState();

                  const cards = Array.from(document.querySelectorAll('.video-card'));
                  const currentIndex = cards.indexOf(card);
                  render();

                  const newCards = Array.from(document.querySelectorAll('.video-card'));
                  if (newCards.length > 0) {
                    const nextIndex = Math.min(currentIndex, newCards.length - 1);
                    newCards[nextIndex].focus();
                    lastFocusedCardId = newCards[nextIndex].dataset.id;
                  }
                }
              }, 50);
            }, HOLD_DELAY);
          } else if (!isUpNext) {
            buttonReleased = false;
            holdCard = card;
          }
        }
        
        if (e.key === 'c' || e.key === 'ContextMenu') {
          e.preventDefault();
          openContextMenu(card);
        }
      });
      
      card.addEventListener('keyup', (e) => {
        if (document.getElementById('playerView').classList.contains('active')) return;

        if (e.key === 'Enter' || e.key === ' ') {
          card.classList.remove('pressed');

          // ONLY process if THIS card received the keydown
          if (!card.dataset.keydownReceived) {
            // Reset buttonReleased to prevent blocking future interactions
            buttonReleased = true;
            return;
          }

          // Clear the flag
          delete card.dataset.keydownReceived;

          const isUpNext = card.dataset.inUpnext === 'true';

          if (isUpNext && holdCard === card) {
            const holdElapsed = Date.now() - holdStartTime;

            if (holdElapsed < HOLD_DELAY) {
              resetHoldState();
              buttonReleased = true;
              playVideo(card.dataset.id);
            } else {
              resetHoldState();
              buttonReleased = true;
            }
          } else if (!isUpNext && holdCard === card) {
            resetHoldState();
            buttonReleased = true;
            playVideo(card.dataset.id);
          } else {
            buttonReleased = true;
          }
        }
      });
      
      card.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        openContextMenu(card);
      });
    });

    // Series card handlers
    document.querySelectorAll('.series-card').forEach(card => {
      const openSeries = () => {
        currentView = 'series';
        currentSeries = card.dataset.series;
        currentSeason = null;
        lastFocusedCardId = null;
        render();
      };

      card.addEventListener('click', openSeries);
      card.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          card.dataset.keydownReceived = 'true';
          card.classList.add('pressed');
        }
      });
      card.addEventListener('keyup', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          card.classList.remove('pressed');

          // Only process if THIS card received keydown
          if (!card.dataset.keydownReceived) {
            return;
          }
          delete card.dataset.keydownReceived;

          openSeries();
        }
      });
    });
  }

  function restoreFocus() {
    if (lastFocusedCardId) {
      const lastCard = document.querySelector(`[data-id="${lastFocusedCardId}"]`);
      if (lastCard) {
        lastCard.focus();
        lastCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      } else {
        focusFirstCard();
      }
    } else {
      focusFirstCard();
    }
  }

  function resetHoldState() {
    if (holdTimer) {
      clearTimeout(holdTimer);
      holdTimer = null;
    }
    if (holdProgressInterval) {
      clearInterval(holdProgressInterval);
      holdProgressInterval = null;
    }
    if (holdCard) {
      holdCard.classList.remove('holding');
      holdCard.classList.remove('pressed');
      const overlay = holdCard.querySelector('.hold-overlay');
      const fillBar = holdCard.querySelector('.hold-overlay .fill');
      if (overlay) overlay.classList.remove('visible');
      if (fillBar) fillBar.style.width = '0%';
      holdCard = null;
    }
    holdStartTime = null;
  }

  function focusFirstCard() {
    const firstCard = document.querySelector('.video-card');
    if (firstCard) firstCard.focus();
  }

  // Context Menu
  function openContextMenu(card) {
    const menu = document.getElementById('contextMenu');
    const rect = card.getBoundingClientRect();
    contextMenuVideoId = card.dataset.id;
    lastFocusedCardId = card.dataset.id; // Track for focus return

    // Check if this video is in continue watching
    const progress = getProgress(contextMenuVideoId);
    const percent = progress && progress.duration ? progress.position / progress.duration : 0;
    const watchedSeconds = progress ? progress.position : 0;
    const inContinueWatching = progress && progress.duration && 
      (watchedSeconds > 10 || percent > 0.02) && 
      percent < 0.98;

    // Show/hide remove option based on whether it's in continue watching
    const removeItem = menu.querySelector('[data-action="remove"]');
    removeItem.style.display = inContinueWatching ? 'block' : 'none';

    // Position menu
    let top = rect.top;
    let left = rect.right + 10;

    // Keep menu in viewport horizontally
    if (rect.right + 220 > window.innerWidth) {
      left = rect.left - 210;
    }

    // Keep menu in viewport vertically (Fix 8)
    const menuHeight = 100; // Approximate menu height
    if (top + menuHeight > window.innerHeight) {
      top = window.innerHeight - menuHeight - 10;
    }
    if (top < 10) top = 10;

    menu.style.top = `${top}px`;
    menu.style.left = `${left}px`;

    menu.classList.add('visible');
    
    // Focus first visible item (Fix 9)
    const visibleItems = Array.from(menu.querySelectorAll('.context-menu-item'))
      .filter(item => item.style.display !== 'none');
    if (visibleItems.length > 0) {
      visibleItems[0].focus();
    }
  }

  function closeContextMenu() {
    const menu = document.getElementById('contextMenu');
    menu.classList.remove('visible');
    contextMenuVideoId = null;
    
    // Return focus to card
    if (lastFocusedCardId) {
      const card = document.querySelector(`[data-id="${lastFocusedCardId}"]`);
      if (card) card.focus();
    }
  }

  // Context menu event handlers
  document.getElementById('contextMenu').addEventListener('click', (e) => {
    const action = e.target.dataset.action;
    if (action && contextMenuVideoId) {
      if (action === 'remove') {
        removeFromHistory(contextMenuVideoId);
        showToast('Removed from Up Next');
        render();
      } else if (action === 'markComplete') {
        markAsComplete(contextMenuVideoId);
        showToast('Marked as watched');
        render();
      }
      closeContextMenu();
    }
  });

  document.getElementById('contextMenu').addEventListener('keydown', (e) => {
    if (e.key === 'Escape' || e.key === 'Backspace') {
      closeContextMenu();
    } else if (e.key === 'Enter' || e.key === ' ') {
      e.target.click();
    } else if (e.key === 'ArrowDown') {
      const next = e.target.nextElementSibling;
      if (next) next.focus();
    } else if (e.key === 'ArrowUp') {
      const prev = e.target.previousElementSibling;
      if (prev) prev.focus();
    }
  });

  // Close context menu when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.context-menu') && !e.target.closest('.video-card')) {
      closeContextMenu();
    }
  });

  // D-pad / Arrow key navigation
  document.addEventListener('keydown', (e) => {
    const playerView = document.getElementById('playerView');
    if (playerView.classList.contains('active')) return;

    // Back navigation from series view
    if ((e.key === 'Escape' || e.key === 'Backspace') && currentView === 'series') {
      e.preventDefault();
      goBackToHome();
      return;
    }

    // Cancel hold if navigating away
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
      if (holdTimer || holdProgressInterval) {
        resetHoldState();
        buttonReleased = true;
      }
    }

    // Close context menu on any navigation
    const contextMenu = document.getElementById('contextMenu');
    if (contextMenu.classList.contains('visible') && !e.target.closest('.context-menu')) {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Escape'].includes(e.key)) {
        closeContextMenu();
        return;
      }
    }

    // Skip global navigation for episode items and season tabs (they have their own handlers)
    if (e.target.classList.contains('episode-item') || 
        e.target.classList.contains('season-tab') ||
        e.target.classList.contains('series-back')) {
      return;
    }
    
    const cards = Array.from(document.querySelectorAll('.video-card'));
    const currentIndex = cards.indexOf(document.activeElement);
    
    if (currentIndex === -1) {
      if (cards.length > 0 && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        cards[0].focus();
        lastFocusedCardId = cards[0].dataset.id;
      }
      return;
    }

    // Get all grids and their card ranges
    const grids = Array.from(document.querySelectorAll('.video-grid'));
    let currentGridIndex = 0;
    let cardOffset = 0;
    
    for (let i = 0; i < grids.length; i++) {
      const gridCards = grids[i].querySelectorAll('.video-card').length;
      if (currentIndex < cardOffset + gridCards) {
        currentGridIndex = i;
        break;
      }
      cardOffset += gridCards;
    }

    const currentGrid = grids[currentGridIndex];
    const gridStyle = getComputedStyle(currentGrid);
    const columns = gridStyle.gridTemplateColumns.split(' ').length;
    const indexInGrid = currentIndex - cardOffset;
    const gridCards = currentGrid.querySelectorAll('.video-card').length;

    let newIndex = currentIndex;

    switch (e.key) {
      case 'ArrowRight':
        newIndex = Math.min(currentIndex + 1, cards.length - 1);
        break;
      case 'ArrowLeft':
        newIndex = Math.max(currentIndex - 1, 0);
        break;
      case 'ArrowDown':
        // Check if we'd go past current grid
        if (indexInGrid + columns >= gridCards) {
          // Jump to next section
          if (currentGridIndex < grids.length - 1) {
            const nextGridStart = cardOffset + gridCards;
            newIndex = nextGridStart;
          }
        } else {
          newIndex = Math.min(currentIndex + columns, cards.length - 1);
        }
        break;
      case 'ArrowUp':
        // Check if we'd go before current grid
        if (indexInGrid - columns < 0) {
          // In series view, focus active season tab
          if (currentView === 'series' && currentGridIndex === 0) {
            const activeTab = document.querySelector('.season-tab.active');
            if (activeTab) {
              activeTab.focus();
              return;
            }
          }
          // Jump to previous section
          if (currentGridIndex > 0) {
            newIndex = cardOffset - 1; // Last card of previous grid
          }
        } else {
          newIndex = Math.max(currentIndex - columns, 0);
        }
        break;
      default:
        return;
    }

    if (newIndex !== currentIndex) {
      e.preventDefault();
      cards[newIndex].focus();
      cards[newIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
      lastFocusedCardId = cards[newIndex].dataset.id;
    }
  });

  // Player
  let currentVideo = null;
  let saveInterval = null;
  let headerHideTimeout = null;

  async function playVideo(fileId) {
    const video = videos.find(v => v.id === fileId);
    if (!video) return;

    // Save focused card for returning
    lastFocusedCardId = fileId;

    // Add loading state to card
    const card = document.querySelector(`[data-id="${fileId}"]`);
    if (card) card.classList.add('loading');

    try {
      const streamUrl = await getStreamUrl(video.path);
      
      // Remove loading state
      if (card) card.classList.remove('loading');

      currentVideo = video;
      
      const playerView = document.getElementById('playerView');
      const playerTitle = document.getElementById('playerTitle');
      const videoPlayer = document.getElementById('videoPlayer');
      const playPauseBtn = document.getElementById('playPauseBtn');
      const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');
      const subtitlesBtn = document.getElementById('subtitlesBtn');

      playerTitle.textContent = stripExtension(video.name);
      playerView.classList.add('active');
      document.activeElement.blur();
      
      // Check for next episode
      const nextEp = getNextEpisode(video);
      if (nextEp) {
        nextEpisodeBtn.style.display = 'flex';
        nextEpisodeBtn.dataset.nextId = nextEp.id;
      } else {
        nextEpisodeBtn.style.display = 'none';
      }

      // Check for subtitles
      if (videoPlayer.textTracks && videoPlayer.textTracks.length > 0) {
        subtitlesBtn.style.display = 'flex';
      } else {
        subtitlesBtn.style.display = 'none';
      }

      // Reset play/pause button state
      playPauseBtn.classList.remove('playing');
      
      // Restore position after metadata loads
      const progress = getProgress(video.id);
      const onLoadedMetadata = () => {
        if (progress && progress.position > 0 && progress.position < videoPlayer.duration) {
          videoPlayer.currentTime = progress.position;
        }
        updateProgress(video.id, videoPlayer.currentTime, videoPlayer.duration);
        updateTimeDisplay();
        videoPlayer.removeEventListener('loadedmetadata', onLoadedMetadata);
      };
      videoPlayer.addEventListener('loadedmetadata', onLoadedMetadata);
      
      videoPlayer.src = streamUrl;

      // Handle autoplay rejection
      try {
        await videoPlayer.play();
        playPauseBtn.classList.add('playing');
      } catch (playError) {
        console.warn('Autoplay prevented:', playError);
      }

      // Save progress every 3 seconds
      saveInterval = setInterval(() => {
        if (!videoPlayer.paused && videoPlayer.duration) {
          updateProgress(video.id, videoPlayer.currentTime, videoPlayer.duration);
        }
      }, 3000);

      // Show controls and focus play button for TV remote
      showPlayerUI();
      setTimeout(() => {
        document.getElementById('playPauseBtn').focus();
      }, 100);

    } catch (err) {
      if (card) card.classList.remove('loading');
      showToast('Failed to load video: ' + err.message, true);
    }
  }

  // Get next episode for current video
  function getNextEpisode(video) {
    if (!video.pathDisplay) return null;
    
    const pathParts = video.pathDisplay.split('/').filter(p => p);
    if (pathParts[0]?.toLowerCase() !== 'series' || pathParts.length < 4) return null;
    
    const showName = pathParts[1];
    const seasonName = pathParts[2];
    
    if (!series[showName] || !series[showName].seasons[seasonName]) return null;
    
    const episodes = series[showName].seasons[seasonName];
    const currentIndex = episodes.findIndex(ep => ep.id === video.id);
    
    if (currentIndex >= 0 && currentIndex < episodes.length - 1) {
      return episodes[currentIndex + 1];
    }
    
    // Check next season
    const seasons = Object.keys(series[showName].seasons).sort((a, b) => {
      const numA = parseInt(a.match(/\d+/)?.[0] || 0);
      const numB = parseInt(b.match(/\d+/)?.[0] || 0);
      return numA - numB;
    });
    
    const seasonIndex = seasons.indexOf(seasonName);
    if (seasonIndex >= 0 && seasonIndex < seasons.length - 1) {
      const nextSeason = seasons[seasonIndex + 1];
      const nextSeasonEpisodes = series[showName].seasons[nextSeason];
      if (nextSeasonEpisodes && nextSeasonEpisodes.length > 0) {
        return nextSeasonEpisodes[0];
      }
    }
    
    return null;
  }

  // Show seek indicator
  let seekIndicatorTimeout = null;
  function showSeekIndicator(text) {
    const indicator = document.getElementById('seekIndicator');
    indicator.textContent = text;
    indicator.classList.add('visible');
    
    clearTimeout(seekIndicatorTimeout);
    seekIndicatorTimeout = setTimeout(() => {
      indicator.classList.remove('visible');
    }, 800);
  }

  // Format time for display
  function formatTime(seconds) {
    if (isNaN(seconds) || !isFinite(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  // Update time display and progress
  function updateTimeDisplay() {
    const videoPlayer = document.getElementById('videoPlayer');
    const currentTimeEl = document.getElementById('currentTime');
    const durationEl = document.getElementById('duration');
    const progressPlayed = document.getElementById('progressPlayed');
    const progressThumb = document.getElementById('progressThumb');
    
    currentTimeEl.textContent = formatTime(videoPlayer.currentTime);
    durationEl.textContent = formatTime(videoPlayer.duration);
    
    if (videoPlayer.duration) {
      const percent = (videoPlayer.currentTime / videoPlayer.duration) * 100;
      progressPlayed.style.width = `${percent}%`;
      progressThumb.style.left = `${percent}%`;
    }
  }

  // Player UI auto-hide (TV friendly)
  function showPlayerUI() {
    const header = document.getElementById('playerHeader');
    const controls = document.getElementById('playerControls');
    
    header.classList.remove('hidden');
    controls.classList.remove('hidden');

    clearTimeout(headerHideTimeout);
    headerHideTimeout = setTimeout(() => {
      const videoPlayer = document.getElementById('videoPlayer');
      const buttons = Array.from(document.querySelectorAll('#controlsRow .tv-control-btn'));
      const isButtonFocused = buttons.includes(document.activeElement);
      
      // Don't hide if paused or if a control button is focused
      if (!videoPlayer.paused && !isButtonFocused) {
        header.classList.add('hidden');
        controls.classList.add('hidden');
      }
    }, 4000);
  }

  function closePlayer() {
    const playerView = document.getElementById('playerView');
    const videoPlayer = document.getElementById('videoPlayer');

    // Save final position
    if (currentVideo && videoPlayer.duration) {
      updateProgress(currentVideo.id, videoPlayer.currentTime, videoPlayer.duration);
    }

    videoPlayer.pause();
    videoPlayer.src = '';
    playerView.classList.remove('active');
    currentVideo = null;

    if (saveInterval) {
      clearInterval(saveInterval);
      saveInterval = null;
    }

    if (headerHideTimeout) {
      clearTimeout(headerHideTimeout);
      headerHideTimeout = null;
    }

    render(); // Re-render to update continue watching
  }

  // Event Listeners
  document.getElementById('backBtn').addEventListener('click', closePlayer);

  // TV Control button handlers
  document.getElementById('playPauseBtn').addEventListener('click', () => {
    const videoPlayer = document.getElementById('videoPlayer');
    if (videoPlayer.paused) {
      videoPlayer.play();
    } else {
      videoPlayer.pause();
    }
  });

  document.getElementById('restartBtn').addEventListener('click', () => {
    const videoPlayer = document.getElementById('videoPlayer');
    videoPlayer.currentTime = 0;
    videoPlayer.play();
    document.getElementById('playPauseBtn').focus();
  });

  document.getElementById('rewindBtn').addEventListener('click', () => {
    const videoPlayer = document.getElementById('videoPlayer');
    videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 10);
    updateTimeDisplay();
    showSeekIndicator('−10s');
  });

  document.getElementById('forwardBtn').addEventListener('click', () => {
    const videoPlayer = document.getElementById('videoPlayer');
    videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 10);
    updateTimeDisplay();
    showSeekIndicator('+10s');
  });

  document.getElementById('nextEpisodeBtn').addEventListener('click', () => {
    const btn = document.getElementById('nextEpisodeBtn');
    const nextId = btn.dataset.nextId;
    if (nextId) {
      closePlayer();
      playVideo(nextId);
    }
  });

  document.getElementById('subtitlesBtn').addEventListener('click', () => {
    const videoPlayer = document.getElementById('videoPlayer');
    const btn = document.getElementById('subtitlesBtn');
    
    if (videoPlayer.textTracks && videoPlayer.textTracks.length > 0) {
      const track = videoPlayer.textTracks[0];
      if (track.mode === 'showing') {
        track.mode = 'hidden';
        btn.classList.remove('active');
      } else {
        track.mode = 'showing';
        btn.classList.add('active');
      }
    }
  });

  // Video element event listeners
  const videoPlayer = document.getElementById('videoPlayer');
  
  videoPlayer.addEventListener('play', () => {
    const btn = document.getElementById('playPauseBtn');
    btn.classList.add('playing');
    btn.dataset.label = 'Pause';
  });

  videoPlayer.addEventListener('pause', () => {
    const btn = document.getElementById('playPauseBtn');
    btn.classList.remove('playing');
    btn.dataset.label = 'Play';
    showPlayerUI();
  });

  videoPlayer.addEventListener('timeupdate', updateTimeDisplay);

  videoPlayer.addEventListener('progress', () => {
    const buffered = document.getElementById('progressBuffered');
    if (videoPlayer.buffered.length > 0) {
      const percent = (videoPlayer.buffered.end(videoPlayer.buffered.length - 1) / videoPlayer.duration) * 100;
      buffered.style.width = `${percent}%`;
    }
  });

  videoPlayer.addEventListener('ended', () => {
    const nextBtn = document.getElementById('nextEpisodeBtn');
    if (nextBtn.style.display !== 'none' && nextBtn.dataset.nextId) {
      showToast('Next episode in 5s...');
      nextBtn.focus();
      setTimeout(() => {
        const nextId = nextBtn.dataset.nextId;
        if (nextId && document.getElementById('playerView').classList.contains('active')) {
          closePlayer();
          playVideo(nextId);
        }
      }, 5000);
    }
    showPlayerUI();
  });

  // Progress bar scrubbing (mouse/touch)
  const progressContainer = document.getElementById('progressContainer');
  let isScrubbing = false;

  function getProgressPercent(e, container) {
    const rect = container.getBoundingClientRect();
    const x = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    return Math.max(0, Math.min(1, (x - rect.left) / rect.width));
  }

  function updateHoverTime(e) {
    const percent = getProgressPercent(e, progressContainer);
    const time = percent * (videoPlayer.duration || 0);
    const hoverTime = document.getElementById('progressHoverTime');
    const rect = progressContainer.getBoundingClientRect();
    const x = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    
    hoverTime.textContent = formatTime(time);
    // Keep tooltip within bounds
    const tooltipX = Math.max(30, Math.min(rect.width - 30, x - rect.left));
    hoverTime.style.left = `${tooltipX}px`;
  }

  function scrubTo(e) {
    const percent = getProgressPercent(e, progressContainer);
    const time = percent * videoPlayer.duration;
    videoPlayer.currentTime = time;
    updateTimeDisplay();
  }

  progressContainer.addEventListener('mouseenter', () => showPlayerUI());
  
  progressContainer.addEventListener('mousemove', (e) => {
    updateHoverTime(e);
    if (isScrubbing) {
      scrubTo(e);
    }
  });

  progressContainer.addEventListener('mousedown', (e) => {
    isScrubbing = true;
    progressContainer.classList.add('scrubbing');
    scrubTo(e);
  });

  document.addEventListener('mousemove', (e) => {
    if (isScrubbing) {
      const rect = progressContainer.getBoundingClientRect();
      const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      videoPlayer.currentTime = percent * videoPlayer.duration;
      updateTimeDisplay();
    }
  });

  document.addEventListener('mouseup', () => {
    if (isScrubbing) {
      isScrubbing = false;
      progressContainer.classList.remove('scrubbing');
    }
  });

  // Touch support for scrubbing
  progressContainer.addEventListener('touchstart', (e) => {
    isScrubbing = true;
    progressContainer.classList.add('scrubbing');
    scrubTo(e);
  }, { passive: true });

  progressContainer.addEventListener('touchmove', (e) => {
    if (isScrubbing) {
      scrubTo(e);
      updateHoverTime(e);
    }
  }, { passive: true });

  progressContainer.addEventListener('touchend', () => {
    isScrubbing = false;
    progressContainer.classList.remove('scrubbing');
  });

  // Click to seek
  progressContainer.addEventListener('click', (e) => {
    scrubTo(e);
  });

  // Get visible control buttons
  function getVisibleControlButtons() {
    return Array.from(document.querySelectorAll('#controlsRow .tv-control-btn'))
      .filter(btn => btn.style.display !== 'none');
  }

  // Focus play button when player opens
  function focusPlayButton() {
    document.getElementById('playPauseBtn').focus();
  }

  // TV Remote / D-pad navigation for player
  document.addEventListener('keydown', (e) => {
    const playerView = document.getElementById('playerView');
    
    if (playerView.classList.contains('active')) {
      const videoPlayer = document.getElementById('videoPlayer');
      const buttons = getVisibleControlButtons();
      const focusedBtn = document.activeElement;
      const focusedIndex = buttons.indexOf(focusedBtn);
      const isButtonFocused = focusedIndex !== -1;
      
      showPlayerUI();

      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          e.stopPropagation();
          if (isButtonFocused && focusedIndex > 0) {
            buttons[focusedIndex - 1].focus();
          } else if (!isButtonFocused) {
            // Seek when no button focused
            videoPlayer.currentTime = Math.max(0, videoPlayer.currentTime - 10);
            updateTimeDisplay();
            showSeekIndicator('−10s');
          }
          return;
          
        case 'ArrowRight':
          e.preventDefault();
          e.stopPropagation();
          if (isButtonFocused && focusedIndex < buttons.length - 1) {
            buttons[focusedIndex + 1].focus();
          } else if (!isButtonFocused) {
            videoPlayer.currentTime = Math.min(videoPlayer.duration, videoPlayer.currentTime + 10);
            updateTimeDisplay();
            showSeekIndicator('+10s');
          }
          return;
          
        case 'ArrowUp':
          e.preventDefault();
          e.stopPropagation();
          // Unfocus controls to allow seeking with left/right
          if (isButtonFocused) {
            focusedBtn.blur();
          }
          return;
          
        case 'ArrowDown':
          e.preventDefault();
          e.stopPropagation();
          // Show controls and focus play button
          if (!isButtonFocused) {
            focusPlayButton();
          }
          return;
          
        case 'Enter':
        case ' ':
          e.preventDefault();
          e.stopPropagation();
          if (isButtonFocused) {
            focusedBtn.click();
          } else {
            // Toggle play/pause
            if (videoPlayer.paused) {
              videoPlayer.play();
            } else {
              videoPlayer.pause();
            }
          }
          return;
          
        case 'MediaPlayPause':
          e.preventDefault();
          e.stopPropagation();
          if (videoPlayer.paused) {
            videoPlayer.play();
          } else {
            videoPlayer.pause();
          }
          return;
          
        case 'MediaPlay':
          e.preventDefault();
          e.stopPropagation();
          videoPlayer.play();
          return;
          
        case 'MediaPause':
        case 'MediaStop':
          e.preventDefault();
          e.stopPropagation();
          videoPlayer.pause();
          return;
          
        case 'Escape':
        case 'Backspace':
          e.preventDefault();
          e.stopPropagation();
          closePlayer();
          return;
      }
      
      // Android back button
      if (e.keyCode === 4) {
        e.preventDefault();
        e.stopPropagation();
        closePlayer();
        return;
      }
    }
  }, true);

  // Save progress on video time update (throttled by interval) and when seeking
  document.getElementById('videoPlayer').addEventListener('seeked', () => {
    if (currentVideo) {
      const videoPlayer = document.getElementById('videoPlayer');
      if (videoPlayer.duration) {
        updateProgress(currentVideo.id, videoPlayer.currentTime, videoPlayer.duration);
      }
    }
  });

  // Clock
  function updateClock() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const ampm = hours >= 12 ? 'PM' : 'AM';
    const displayHours = hours % 12 || 12;
    document.getElementById('clock').textContent = `${displayHours}:${minutes} ${ampm}`;
  }
  
  updateClock();
  setInterval(updateClock, 1000);

  // Init
  async function init() {
    const app = document.getElementById('app');

    // Check config
    if (!CONFIG.appKey || !CONFIG.appSecret || !CONFIG.refreshToken) {
      app.innerHTML = `
        <div class="config-prompt">
          <h1>Setup Required</h1>
          <p>One-time setup for permanent access:</p>
          <ol style="text-align: left; margin: 20px 0; line-height: 2;">
            <li>Go to <a href="https://www.dropbox.com/developers/apps" target="_blank" style="color: #5e5ce6;">dropbox.com/developers/apps</a></li>
            <li>Create app → Scoped access → App folder</li>
            <li>In Permissions tab, enable: <strong>files.content.read</strong> and <strong>files.content.write</strong></li>
            <li>Copy <strong>App key</strong> and <strong>App secret</strong></li>
            <li>Get refresh token by visiting:<br>
              <code style="font-size: 0.75rem; padding: 8px; margin: 8px 0; display: block; word-break: break-all;">https://www.dropbox.com/oauth2/authorize?client_id=YOUR_APP_KEY&response_type=code&token_access_type=offline</code>
            </li>
            <li>Copy the code and exchange it:<br>
              <code style="font-size: 0.75rem; padding: 8px; margin: 8px 0; display: block;">curl -X POST https://api.dropboxapi.com/oauth2/token \\
  -u "APP_KEY:APP_SECRET" \\
  -d grant_type=authorization_code \\
  -d code=YOUR_CODE</code>
            </li>
            <li>Copy <strong>refresh_token</strong> from response</li>
          </ol>
          <p>Then edit this file:</p>
          <code>const CONFIG = {
  appKey: 'YOUR_APP_KEY',
  appSecret: 'YOUR_APP_SECRET',
  refreshToken: 'YOUR_REFRESH_TOKEN',
  folderPath: ''
};</code>
        </div>
      `;
      return;
    }

    try {
      // Load watch history from Dropbox first
      app.innerHTML = '<div class="loading">Loading watch history...</div>';
      watchHistory = await loadWatchHistoryFromDropbox();
      
      app.innerHTML = '<div class="loading">Loading videos...</div>';
      videos = await listVideos();
      render();
    } catch (err) {
      app.innerHTML = `<div class="error">Failed to load: ${err.message}</div>`;
    }
  }

  init();
</script>

</body>
</html>
